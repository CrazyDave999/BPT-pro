# 并发B+树思路与总结 - CrazyDave

## 问题

关于怎么实现B+树，前人之述备矣。然而这次大作业中~~善良的~~助教们让我们实现**并发**的文件存储系统，这让我感到十分~~困惑~~开心。并发情境下，一个线程想要访问的资源所在位置的局部随时可能被另一个线程篡改，这可能导致访问失败或结果错误。考虑采用加锁的方法来保证并发安全。在下文中，约定“节点”，“页面”，“`page`”是一个东西。

非常感谢*xiaoh*对我的大力指导和帮助。

## 思路

让我们从简单的想法开始逐步优化。

### 一把大锁

最省心的当然是直接用一个`shared_mutex`锁住整个数据结构。这样做固然是正确的，但当有写操作在进行时所有读操作都将受到阻塞，所有的写操作之间都是串行运行，没有达到最大并发。

### 锁住整条路径

既然一把大锁太影响并发性能，考虑减小锁的粒度，把锁放进`page`里面去，经过一个`page`就把它上锁。这样相比一把大锁的好处是一些读操作还在运行时，即可开始一次新的写操作。由于B+树平衡调整最坏情况上溯到根，所以写操作时会把从根到叶子的整条路径锁住。遗憾的是，这样做在一次写操作开始之后根就被锁住，所有的读操作都不能在该写操作结束前开始，也会造成较大的阻塞。

### Latch Crabbing

影响性能的主要因素是根部被上写锁之后就相当于整棵树被锁住了，读操作不能进行。注意到平衡调整只是在最坏情况下上溯到根，于是考虑能不能在某些条件下释放掉靠近根的一些祖先的写锁。通过一番搜索，我在互联网上找到了**Latch Crabbing**算法。

首先我们定义“**安全节点**”：插入操作中不会发生分裂的节点（aka. `page->GetSize() < page->GetMaxSize()`），以及删除操作中不需要领养和合并的节点（aka. `page->GetSize() > page->GetMinSize()`）。也就是说在安全节点的子树中进行一次写操作，不会对其祖先造成影响。Latch Crabbing算法总体上还是迭代向下地对`page`加锁，但有一些区别：

- 读操作时，获得了子节点的读锁后即可释放父节点的读锁。
- 写操作时，一般情况下需要一直持有路径上每个节点的写锁，但当遇到安全节点时，即可释放安全节点以上的所有祖先的写锁。这个过程像一个队列，这也是为什么`Context`类中`write_set_`是一个`std::deque`。

完成Latch Crabbing后我的代码在read_qps排名中可以达到24，但在write_qps排名中只能达到203。

### Optimistic Latching

这还没有结束。重新考察Latch Crabbing算法，发现它最大程度地保证了直接完成操作的并发安全，在是否有可能出现并发错误这个问题上，Latch Crabbing是“**绝对悲观**”的，aka. 它在不确定是否可能发生分裂和合并的时候，假定一定出现问题。但是如果没出现问题，那么之前持有的写锁就造成了额外的阻塞。cmu-15-445-2023spring的课件中“BETTER LATCHING ALGORITHM”的部分就提到了一种可解决这个问题的算法，也就是所谓的“乐观锁”优化。

首先注意到一个事实：大部分的写操作都不会造成分裂与合并，即在叶子结点完成操作，不会上溯。基于此可以设计更为“乐观”的算法：

- 读操作，和Latching Crabbing一样。
- 写操作，先假设不需要上溯，沿途对节点加**读锁**，而对叶子结点加写锁。如果发现叶子结点是安全的，那么可以直接操作并返回。如果叶子节点是不安全的，则还原到操作前的状态，释放所有读写锁，按照悲观算法（aka. Latch Crabbing）重新操作。

虽然可能造成重复操作，这个算法使得大多数情况下写操作持有的写锁大大减少，写操作之间的阻塞也会大大减少。我的代码加入Optimistic Latching之后write_qps的表现大大提升，排到22，而read_qps则表现则有所下降，排到85。这也许是因为写操作会阻塞读操作，写操作并发程度增加会阻碍读操作的进行。这也说明在写操作很多时Optimistic Latching的好处会大于坏处，带来一定程度的优化。

### 更多的优化？

在cmu-15-445-2023spring的作业介绍中还提到了在删除操作中，可以用放置墓碑的方式来替代真正的删除，并且在合适的时机对墓碑进行清扫。这样B+树的分裂与删除的频率将会降低，从而进一步提升乐观算法的性能。我没有实现这个优化,，~~因为我不会~~。我们逐步地完善了一个简单并发B+树的设计，然而这还远远不到B+树的上限，~~所以说“我们不能给自己设限”~~。

### 一些细节

- 读操作时锁的获取与释放可以简单地用

```
guard = new_guard;
```

实现，因为`ReadPageGuard`类的赋值重载运算符已经包含了对自身的`Drop()`以及对右值的`move`操作。

- 要注意在资源使用结束后才能对其所有权进行释放，即`Unpin`和`Unlock`等操作要在结束资源使用后才能进行，否则会产生并发错误。例如我犯过的一个错误：

```
···
auto *page = ctx.write_set_.back().AsMut<BPlusTreePage>();
ctx.pop_back();
page->balabala
...
```

在`guard`被析构后对应的锁就被释放，不应该继续使用对应的指针，直到下次再次获得该页面的`guard`。

- 在领养和合并等操作进行时，也要获取对应兄弟节点的写锁，实际上这一点在使用了各种`PageGuard`之后是自然的。另外，一旦领养成功，B+树的平衡就调整完毕，可以直接返回。
- 若在根节点以下没有遇到过安全节点，则不论根节点是否安全（aka. 是否有可能换根），`ctx.write_set_`的队首元素都是根节点的写锁，需要分类讨论一下。
